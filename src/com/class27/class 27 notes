Final keyword with variables:
when used with variables we cannot change the content of that variable.
but if that variable points to an array or any other object we can change the contents of that array
or object.

class A{
int num;
String name;
}

A(int num, String name){
this.number=number;
this.name=name;
}
main method ---

final A var1= new A(123, "Iqra");
var1.number=100;
var1=new A(456, "CJ");
final int[] arr = {123, 145, 456}


arr={100, 58739} // CE because it is declared as final
arr[0]=789;


Final keyword with methods:

class parent{
final void printInfo(){
sout"from parent";
}
}

class Child extends from Parent{
@override
void printInfo(){
sout"From Child" /// CE cannot override a final method
}
}

final with class:
final class ABC{
void method1(){

}
}

No class can extend this class because it is final ^

--------------
Inheritance - parent child relationship
Polymorphism - overriding/overloading
Abstraction
Encapsulation

In Abstraction the internal details of the methods are hidden and we only expose the signature
of the method with return types
Rules:
We can not create the object of the abstract classes because the abstract classes
are incomplete.

